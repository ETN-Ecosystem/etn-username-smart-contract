#include "imports/stdlib.fc";
#include "imports/jetton-op-codes.fc";

;; ================= STORAGE ==================
;; (owner_address, next_item_index, collection_content, nft_item_code, beneficiary_address, jetton_master_address, minted_hashes)
(slice, int, cell, cell, slice, slice, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(),   ;; owner_address
        ds~load_uint(64),     ;; next_item_index (for statistics)
        ds~load_ref(),        ;; collection_content (TEP-64)
        ds~load_ref(),        ;; nft_item_code
        ds~load_msg_addr(),   ;; beneficiary_address
        ds~load_msg_addr(),   ;; jetton_master_address
        ds~load_dict()        ;; minted_hashes (dictionary cell)
    );
}

() save_data(slice owner_address, int next_item_index, cell collection_content, cell nft_item_code, slice beneficiary_address, slice jetton_master_address, cell minted_hashes) impure inline {
    set_data(
        begin_cell()
          .store_slice(owner_address)
          .store_uint(next_item_index, 64)
          .store_ref(collection_content)
          .store_ref(nft_item_code)
          .store_slice(beneficiary_address)
          .store_slice(jetton_master_address)
          .store_dict(minted_hashes)
       .end_cell()
    );
}

;; ================= HELPERS ==================
int calculate_mint_price(int username_len) {
    if (username_len == 3) { return 1000000000000; } ;; 1000 ETN
    if (username_len == 4) { return  900000000000; } ;; 900 ETN
    if (username_len == 5) { return  800000000000; } ;; 800 ETN
    if (username_len == 6) { return  700000000000; } ;; 700 ETN
    return 500000000000; ;; 500 ETN for 7+
}

(slice) calculate_jetton_wallet_address(slice owner_address, slice jetton_master_address) {
    cell state_init = begin_cell()
      .store_uint(0, 2) ;; split_depth, special
      .store_dict(jetton_wallet_code()) ;; Standard library function to get jetton wallet code
      .store_dict(
            begin_cell()
              .store_coins(0)
              .store_slice(owner_address)
              .store_slice(jetton_master_address)
              .store_ref(jetton_wallet_code())
          .end_cell()
        )
      .store_uint(0, 1) ;; library
  .end_cell();
    return address(workchain(), cell_hash(state_init));
}

() deploy_new_nft(int query_id, int item_index, slice new_owner_address, cell item_content, cell nft_item_code, int forward_value) impure {
    cell item_data = begin_cell()
       .store_slice(my_address())      ;; collection_address
       .store_uint(item_index, 256)    ;; item_index (now 256-bit hash)
       .store_slice(new_owner_address) ;; initial owner is the minter
       .store_ref(item_content)
   .end_cell();

    cell state_init = begin_cell()
       .store_uint(4, 3) ;; has code, has data, library is absent
       .store_ref(nft_item_code)
       .store_ref(item_data)
   .end_cell();

    slice item_address = address(workchain(), cell_hash(state_init));

    var msg = begin_cell()
       .store_uint(0x18, 6)
       .store_slice(item_address)
       .store_grams(0)
       .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; has state_init, send all value
       .store_ref(state_init)
       .store_grams(forward_value);

    send_raw_message(msg.end_cell(), 128); ;; mode 128: send all remaining balance
}

;; ================= MAIN =====================
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    var (owner_address, next_item_index, collection_content, nft_item_code, beneficiary_address, jetton_master_address, minted_hashes) = load_data();

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    if (op == op::jetton_transfer_notification) {
        int jetton_amount = in_msg_body~load_coins();
        slice from_address = in_msg_body~load_msg_addr();
        slice forward_payload = in_msg_body~load_ref().begin_parse();

        ;; 1. CRITICAL SECURITY CHECK: Verify the notification sender is this collection's jetton wallet.
        slice expected_jetton_wallet = calculate_jetton_wallet_address(my_address(), jetton_master_address);
        throw_unless(403, equal_slices(sender_address, expected_jetton_wallet));

        ;; 2. PAYMENT VALIDATION: Check if the sent amount matches the required price.
        int username_len = slice_bits(forward_payload) / 8; ;; Assuming simple ASCII/UTF8 string
        int required_price = calculate_mint_price(username_len);
        throw_unless(406, jetton_amount == required_price);

        ;; 3. UNIQUENESS CHECK: Check if the username hash already exists.
        int item_index = string_hash(forward_payload);
        (slice _, int found) = minted_hashes.udict_get?(256, item_index);
        throw_if(409, found); ;; 409 Conflict: Username already taken

        ;; 4. MINT EXECUTION: All checks passed.
        ;; 4a. Deploy the new NFT item, owned by the user.
        cell item_content = begin_cell().store_slice(forward_payload).end_cell();
        deploy_new_nft(query_id, item_index, from_address, item_content, nft_item_code, msg_value - my_balance);

        ;; 4b. Update the on-chain registry of minted names.
        minted_hashes~udict_set(256, item_index, begin_cell().store_uint(1, 1).end_cell().begin_parse());

        ;; 4c. Update collection state and forward funds.
        save_data(owner_address, next_item_index + 1, collection_content, nft_item_code, beneficiary_address, jetton_master_address, minted_hashes);

        ;; Forward the received jettons to the beneficiary
        var msg = begin_cell()
           .store_uint(0x18, 6)
           .store_slice(expected_jetton_wallet)
           .store_grams(0)
           .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
           .store_ref(
                begin_cell()
                   .store_uint(op::jetton_transfer, 32)
                   .store_uint(query_id, 64)
                   .store_coins(jetton_amount)
                   .store_slice(beneficiary_address)
                   .store_slice(my_address()) ;; response_destination
                   .store_maybe_ref(null())   ;; custom_payload
                   .store_coins(1)            ;; forward_ton_amount (minimal)
                   .store_maybe_ref(null())   ;; forward_payload
               .end_cell()
            );
        send_raw_message(msg.end_cell(), 1); ;; mode 1: pay gas separately

        return ();
    }

    ;; Handle administrative functions (e.g., change owner)
    throw_unless(401, equal_slices(sender_address, owner_address));
    ;;... admin logic here...

    throw(0xffff); ;; Unknown op
}

;; ================= GET-METHODS ==================
(int, cell, slice, slice, slice) get_collection_data() method_id {
    var (owner_address, next_item_index, collection_content, _, beneficiary_address, jetton_master_address, _) = load_data();
    return (next_item_index, collection_content, owner_address, beneficiary_address, jetton_master_address);
}

slice get_nft_address_by_index(int item_index) method_id {
    var (_, _, _, nft_item_code, _, _, _) = load_data();
    cell item_data = begin_cell()
       .store_slice(my_address())
       .store_uint(item_index, 256)
       .store_slice(address(0,0)) ;; Dummy owner for address calculation
       .store_ref(begin_cell().end_cell()) ;; Dummy content
   .end_cell();

    cell state_init = begin_cell()
       .store_uint(4, 3)
       .store_ref(nft_item_code)
       .store_ref(item_data)
   .end_cell();

    return address(workchain(), cell_hash(state_init));
}
